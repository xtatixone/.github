# 6.0 Macro Patterns

XTATIX utilizes a Layer-Based Macro System. In this territory, every sketch or style tag is a processing unit that maintains two distinct internal memories: a Render Stack and a Reference Stack.

### Macro blocks

Self-closing tags are identified as macro declarations. Inputs are passed as sequential & attributes.

```html
<sketch
  &="operation 1"
  &="operation 2" />

<style
  &="operation 1"
  &="operation 2" />
```

### The Two Stacks Rule

The behavior of the `&` attribute is determined by the use of the Assignment Operator (`=`).

1. The Render Stack (Direct Injection): Using `=` without a leading symbol (e.g., `&="= value"`) appends content directly to the output buffer of that block.
2. The Reference Stack (Key-Value Storage): Using `=` with a symbol/key (e.g., `&="key=value"`) stores a variable.
3. The Injection Pass (The "Wash"): Crucially, the assign operator is active. Every time a new & line is processed, the engine scans the current Render Stack and replaces any occurrences of keys found in the Reference Stack.

> **Caution:** Because replacement is "dumb" (string-based), ensure your keys are unique enough not to accidentally collide with standard HTML tags or properties.

### The Multiplier Operator (*)

To generate repetitive structures, use the `*` operator within a Render Stack assignment.

- **Syntax:** `&="[count]*[content]"`
- **Count:** If omitted (e.g., `&="= *value"`), it defaults to 1.
- **Content:** If the string after the `*` matches a Symbolic Class (an existing `$sketch`), that sketch is expanded into the stack.

```html
<sketch &="= 2*value" />

<sketch 
  &="$N=4" 
  &="= $N*value" />
```

### The Tunneling Pattern

Because the assignment operator replaces string occurrences within the existing Render Stack, you can "tunnel" data deep into nested structures.

When you inject a Sketch into the Render Stack, its "holes" (e.g., `{title}`) become part of the current buffer. Subsequent layers can then "reach into" that buffer and fill those holes.

```html
<sketch _$btn &="={text}">
    <button>{text}</button>
</sketch>

<sketch 
  &="= *$$index"
  &="{{content}}= *$btn"
  &="{{text}}=Click Me" />
```

### Recursive Value Population

By combining multipliers and tunneling, you can populate complex, nested values. In the example below, `{innerbutton}` acts as a conduit that carries data from the top-level macro down into the nested `$innerbutton` sketch.

```html

<sketch _$innerbutton 
&="={buttoncontent}">
{buttoncontent}
</sketch>

<!--  -->
<sketch 
_$innercard 
&="
    ={innercard}
    ={innerbutton}
"> 
    {innercard}

<sketch 
&="= *$innerbutton"
&="{buttoncontent}={innerbutton}" />

</sketch>

<sketch _$preview>
    <sketch
    &="$N= 12" 
    &="= *$innercard"
    &="{innercard}=2*CARD" 
    &="{innerbutton}=SUBMIT<br/>" />
</sketch>
```
