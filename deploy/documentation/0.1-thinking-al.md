# 0.1 Thinking with AL

Alchira treats HTML and CSS as one language: you describe *what the UI is* and *how it should look* in the same place. The compiler handles selectors, cascade, and CSS output automatically.

### Start from structure, not selectors

- Model pages as sketches and regions (card, header, layout) instead of loose DOM nodes styled later.
- Each sketch has a unique symlink—a symbolic handle used for both styling and preview.
- Because structure and style share the same symclass, the editor can instantly render or navigate to any sketch.
- Each block owns its markup and styles, so you design by meaning, not selectors.
- Small or one‑off pieces can be written inline without a sketch.

```html
<sketch global$symlink="/* styles */">
  <h1>Heading</h1>
  <button global$$button-1="--var: val;">Submit</button>
</sketch>
```

### Declare visual intent, not mechanics

- Sketches speed up early prototyping—perfect for quick layout and preview.
- For throwaway UIs, reuse utilities; for reusable parts, define spacing, alignment, and type directly on the sketch.
- When stable, export the sketch into your framework and connect logic there.
 
### Composition over cascade

- Build with composition of sketches and symclasses, not global CSS selectors.
- Variants, themes, and responsive modes are explicit properties or nested blocks—local, predictable, and free of cascade traps.

### The language is the design system

- Colors, spacing, and type tokens are first‑class language concepts.
- Global tokens (prefix `---`) live in `alchira/#constants.css`.
- Local `--` variables act as live, mutable style handles shown in IntelliSense.
- Hovering on `\~global$$button-1` will show which handles can be safely tweaked.  
- Editing a token or symclass safely refactors every dependent component.

### Mental model shift

| Factor | Traditional HTML + CSS | With Alchira |
| --- | --- | --- |
| Context switching | Jumping across templates, CSS, and token files. | One unified artifact—less cognitive friction. |
| Components | Enforced by naming and conventions. | Native in language—composition and reuse are built in. |
| Design tokens | Split across files and tools. | Centralized and semantic—changes propagate safely. |
| Refactoring | Manual, error‑prone cleanup. | Compiler regenerates optimized CSS automatically. |
| Tool Leverage | Generic, name‑based linting. | Smarter IDE features—live previews, rule validation, token introspection. |
