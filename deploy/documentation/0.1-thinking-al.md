# Thinking with AL

Alchira asks you to think about HTML and CSS as one fused, declarative language instead of two files you wire together with class names.  You describe what the UI is and how it should look in one place, and the compiler handles selectors, cascade, and output CSS.

### Start from structure, not selectors

- Model the page as sketches and regions (layout, card, header, sidebar) rather than as loose DOM nodes styled by global selectors.
- Each sketch exposes a unique **symlink** (a symbolic handle) that can be referenced anywhere within its scope.  
- The same symlink powers both styling and preview: because structure and style are tied to the symclass, the editor can jump to and render the sketch at any time in the workflow.  
- Each Alchira block owns both its structure and its styling rules, so you think **“What does this component mean?”** instead of **“Which selector should target this div?”**.  
- Simple, first‑order components can be written inline without sketches when you do not need reuse or dedicated preview.  

```html
<sketch
  global$$symlink="/* css styles */">
  <h1>Heading 1</h1>
  <button
    global$$button-1="--var: val; /* button css styles */">
    Submit
  </button>
</sketch>
```

### Declare visual intent, not mechanics

- Using a sketch is optional, but it is especially helpful during early UI prototyping, where quick preview and restructuring matter more than perfect markup.
- For throwaway or one‑off layouts, you can rely on existing utilities; when you plan to reuse a piece, declare spacing, alignment, and typography on the sketch itself as readable constraints.  
- Once a sketch feels stable, import it into your framework's component logic and wire up data, events, and behavior there.  

### Composition over cascade

- You build UIs by composing sketches and symclasses, not by depending on the global CSS cascade to “trickle down” styles.
- Variants, themes, and responsive behavior are modeled as explicit properties or nested blocks, which keeps behavior local and predictable instead of hidden in distant overrides.  

### Let the language encode the design system

- Tokens like colors, spacing scales, and typography ramps live as first‑class language concepts instead of ad‑hoc variables scattered across stylesheets.
- Global design tokens start with `---` (three dashes) instead of `--` and are declared in `alchira/#constants.css`, forming the shared design vocabulary.  
- Additional variables declared inside symclass styles are treated as *mutable style handles*; they are surfaced in tooltips and IntelliSense. Hovering on `\~global$$button-1` will show which handles can be safely tweaked.  
- This makes design rules testable and shareable: changing a token or a symclass rule in one place can safely refactor every Alchira composition that depends on it.

### Mental model shift

| Factor | Without Alchira (traditional HTML+CSS/tooling) | With Alchira |
| --- | --- | --- |
| Context switching | Frequent jumps between templates, CSS files, and design‑token data; typical setups rely on multiple tools (preprocessors, utility frameworks, purge steps, IDE helpers) to stay productive. | Single language for structure and style; most layout and visual logic lives in one artifact, reducing file‑hopping and cognitive overhead. |
| Component thinking | Component boundaries are enforced by conventions (BEM, CSS Modules, utility naming); architecture tends to drift over time. | Components and sketches are the native unit; composition, variants, and reuse are expressed directly in the DSL, making them easier to maintain and evolve. |
| Design‑system reuse | Tokens, scales, and patterns are split across CSS, JS, and design docs; keeping them in sync costs review time and often causes regressions. | Tokens and rules are part of the language semantics; changing a token updates all dependent compositions deterministically. 
| Refactoring cost | Renaming classes/selectors and reorganizing files is error‑prone; dead CSS and specificity cruft accumulate and slow future work. | Refactors happen at the DSL layer; the compiler regenerates optimized CSS, reducing manual clean‑up and making large changes safer and faster. |
| Tool leverage | 	Generic tools (linters, preprocessors, editors) help, but their view is limited by naming and mixed concerns. | Strong structure enables richer tooling (semantic navigation, live preview, rule validation, token inspectors) that meaningfully cuts iteration time.
